/* This file is part of libtrevisan, a modular implementation of
   Trevisan's randomness extraction construction.

   Copyright (C) 2011-2012, Wolfgang Mauerer <wm@linux-kernel.net>

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with libtrevisan. If not, see <http://www.gnu.org/licenses/>. */

// Generate a list of precomputed irreducible polynomials

#include <NTL/GF2X.h>
#include <NTL/GF2XFactoring.h>
#include <NTL/tools.h>
#include <string>
#include <iostream>
#include <sstream>

NTL_CLIENT

#define MAX_FIELD_ORDER 2048

void gen_irreps_ntl() {
	stringstream ss;
	cout << "// This file is auto-generated by gen_irreps.c, don't modify" << endl;
	cout << "#include <NTL/GF2X.h>" << endl;
	cout << "#include <sstream>" << endl;
	cout << "#include <iostream>" << endl;
	cout << "NTL_CLIENT" << endl;
	cout << "void set_irrep(GF2X &P, unsigned n) {" << endl;
	cout << "stringstream ss;" << endl;
	cout << "switch (n) {" << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// This way of storage is extremely inefficient. But since
		// we're only talking about a few bytes on a big iron machine,
		// who cares...
		cout << "case " << n << ":" << endl;
		cout << "ss << \"" << P << "\";" << endl;
		cout << "ss >> P;" << endl;
		cout << "break;" << endl;
	}

	cout << "default:" << endl;
	cout << "	cerr << \"Internal error: n out of bounds!\";" << endl;
	cout << "	exit(-1);" << endl;
	cout << "}" << endl;
	cout << "}" << endl;
}

void gen_irreps_openssl() {
	stringstream ss;
	cout << "// This file is auto-generated by gen_irreps.c, don't modify" << endl;
	cout << "#include <openssl/bn.h>" << endl;
	cout << "#include <iostream>" << endl;
	cout << "using namespace std;" << endl;
	cout << "void set_irrep(int p[], unsigned n) {" << endl;
	cout << "switch (n) {" << endl;

	for (unsigned n = 1; n <= MAX_FIELD_ORDER; n++) {
		GF2X P;
		BuildSparseIrred(P, n);

		// Sure, there are much more efficient ways to detect the number
		// of set bits
		cout << "case " << n << ": {" << endl;

		int lidx = 0;
		for (long i = deg(P); i >= 0; i--) {
			if (coeff(P, i) == 1)
				cout << "p[" << (lidx++) << "] = " << i << ";" << endl;
		}
		cout << "} break;" << endl;
	}

	cout << "default:" << endl;
	cout << "	cerr << \"Internal error: n out of bounds!\";" << endl;
	cout << "	exit(-1);" << endl;
	cout << "}" << endl;
	cout << "}" << endl;
}

int main(int argc, char **argv) {
	if (argc == 1) // Any argument suffices to generate for openssl
		gen_irreps_ntl();
	else
		gen_irreps_openssl();

	return 0;
}
